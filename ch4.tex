\chapter{Preparation}
\label{chap:preparation}

With the architecture and design decisions established, the focus now shifts to the implementation of the custom and extendable VFS\@.
This concise chapter will outline the tools and technologies employed throughout the development process, ensuring a solid foundation for the implementation phase.


\section{Cross-platform build System}\label{sec:build-system-and-cross-platform-challenges}

CMake~\cite{cmake}, an open-source build system, was selected for this project due to its cross-platform compatibility, user-friendliness, and extensive support for various platforms.
CMake generates native build environments, such as Makefiles or project files for integrated development environments (IDEs), streamlining the development process.

\subsection{Platform-Specific Challenges}\label{subsec:platform-specific-challenges}

Despite the cross-platform advantages provided by CMake, several platform-specific challenges arose during development.
For instance, running applications on an M1 Mac proved difficult due to the lack of compatible binaries for the hardware.
While building the applications from source was an option, there was no compelling reason to do so for the purposes of this thesis.
Furthermore, the osxfuse port had not received an update in five years, exacerbating the situation.
On Windows, WinFsp~\cite{winfsp} is required to ensure FUSE compatibility, introducing additional hurdles for seamless cross-platform development.


\section{Gitlab CI}\label{sec:gitlab-ci}

The MFF faculty GitLab instance was utilized for this project\cite{gitlab_mff}.
GitLab CI/CD pipelines were employed to automate various tasks, such as checking code formatting with clang-format, building the project, running Google Test unit tests, and providing the ability to download build artifacts.
This approach facilitated a more efficient and organized development process.

\subsection{Testing}\label{subsec:testing}

For testing purposes, Google Test was integrated into the GitLab CI/CD pipelines.
This allowed for the execution of simple tests on every commit, such as creating directories and files.
To optimize the testing process, the tests were run on a shared mountpoint that was cleared every time, although this approach is not ideal as it can make it harder to determine the root cause of a failure.
Nonetheless, the primary purpose of these tests was to ensure that basic functionality was not broken with each commit, rather than to diagnose the cause of any failures that occurred.
Overall, the use of GitLab CI/CD and Google Test improved the development process by providing automated testing and more organized project management.

\section{Docker}\label{sec:docker}

Docker\cite{docker} was also incorporated into the project because of several reasons.
First, it allowed for the creation of a consistent and reproducible development environment, ensuring that the project could be built and run across different platforms without issues.
This came in handy because as I wrote this thesis partly using the aforementioned M1 mac, and partly using a Linux machine.
Additionally, Docker provided two methods for deubgging or even demoing the VFS: one that displays debug output in a terminal, and another that runs the VFS in the background.
By integrating Docker into the project, the development and deployment process was simplified, allowing for a more efficient and effective implementation of the custom and extendable VFS.

To create the Docker environment for the project, we started with a base Ubuntu 20.04 image and installed the necessary dependencies for building and running the custom VFS\@.
These dependencies included FUSE, GTest, Boost Program Option, and Libsodium.

The following code block shows the Docker commands used to create and run the custom VFS container.

The first step is optimal, depending whether the container will be used for debugging or actual use, we can create a Docker volume.

\begin{lstlisting}[language=bash, basicstyle=\ttfamily\small]
docker volume create customvfs-test
\end{lstlisting}

Next, we build the Docker image:

\begin{lstlisting}[language=bash, basicstyle=\ttfamily\small]
docker build -t customvfs .
\end{lstlisting}

And after that, we have multiple options for running the container.
Depending on whether we created a Docker volume, we can either mount it or not.
In case of mounting to an actual directory, replace the \texttt{customvfs-test} with the path to the directory.

\xxx{TODO create a shell program that will allow to run the container with different options}

\begin{lstlisting}[language=bash, basicstyle=\ttfamily\small]
docker run --name customvfs-container --rm -it --privileged -v customvfs-test:/mnt/fs customvfs
\end{lstlisting}

\xxx{We also have the option to run the container in the background. And that would require diffrent command passed to docker.}

Overall, the incorporation of Docker into the project provided a consistent and reproducible development environment, simplified the deployment process, and allowed for easier debugging and testing of the custom VFS.