\chapter{Design and Architecture}
\label{chap:design-and-architecture}


\section{Using FUSE in C++}\label{sec:fuse-in-cpp}

Properly incorporating FUSE in C++ presents many challenges, primarily due to its interface design, which necessitates the use of a static wrapper for operations.
The problem arises from FUSE expecting a C struct with pointers to functions, which poses a problem for non-static C++ methods.
To solve this issue, two solutions can be considered: either writing C++ code without utilizing objects, rendering the use of C++ instead of C rather pointless, or implementing a singleton wrapper with only static methods.

As is evident, the latter solution was chosen.
Fortunately, there was no need to start from scratch, as existing repositories already provide a solution to this problem.
However, none of them were complete and up-to-date, and I still had to write some portion of the code myself.

The foundation for this project was built upon the fusexx~\cite{fusexx} repository, which was found most suitable for the needs of this thesis.
But as I said, significant changes were made to the existing code, as it was not written in a modern C++ style and did not adhere to the project's design goals.
The first step was therefore to refactor the code to use modern C++ features and resolve numerous clang-tidy warnings.
Moreover, the repository was not updated for several years, and it was necessary to the change some of the code's version-specific parts.
And as a final touch, some methods were completely rewritten to improve readability or efficiency.

Needless to say, there was also a third, rather ``hacky'' solution, which involved beside other implementation details using a data field in the FUSE context to store a pointer to the C++ object.
Something similar is done in the fusepp~\cite{fusepp} repository.
But this approach did not seem to be the most elegant solution, and it was decided to use the singleton wrapper instead.
Furthermore, the fusepp repository was not updated for even longer and would be harder to be used as a base for the project.


\section{Architecture}\label{sec:architecture}

Once the foundation was laid; the next step was to design a core VFS\@.
It is important to note that this implementation was not the primary focus of this thesis as it was rather focused on providing modularity and extensibility.
The result of this is that the entire core VFS is built on top of already present filesystem in the operating system.
However, such implementation details can be easily replaced, allowing for future improvements.

Multiple approaches were contemplated: one involving a single VFS class and another comprising separate File, Directory, and VFS classes.
Although the latter approach adheres more closely to object-oriented principles, I have decided to go with the former, as it is better suited for use with FUSE as I will still need to somehow bound those classes into one.

\subsection{Modularity}\label{subsec:modularity}

The VFS is designed to be modular, allowing for the addition of new features without the need to modify the core implementation.
To achieve this, the decorator pattern is used.
The decorator pattern is a structural design pattern that involves a set of decorator classes used to wrap concrete components.
Decorator classes mirror the types of the components they decorate, sharing the same interface but adding or overriding behavior.

In the context of this project, the decorator pattern is utilized to add versioning and encryption features without modifying the core VFS implementation.
For example, an \texttt{EncryptionVfs} class is implemented as a decorator, inherited from the \texttt{VfsDecorator} class.
The \texttt{VfsDecorator} class, in turn, inherits from the base \texttt{CustomVfs} class.
The decorator class wraps an instance of the base VFS class, allowing it to perform additional encryption-related tasks when reading or writing files.

Here is a simplified code of the decorator pattern used in this project:

\begin{lstlisting}[language=c++, basicstyle=\ttfamily\small]
class CustomVfs { /.../ };

class VfsDecorator : public CustomVfs {
public:
explicit VfsDecorator(CustomVfs& wrapped_vfs);

protected:
CustomVfs& wrapped_vfs_;
};

class EncryptionVfs : public VfsDecorator {
public:
explicit EncryptionVfs(CustomVfs& wrapped_vfs);

int read(/.../) override;
int write(/.../) override;
};
\end{lstlisting}

The \texttt{VfsDecorator} class wraps an instance of \texttt{CustomVfs} and can be extended by specific decorator implementations, such as \texttt{EncryptionVfs}.
This design allows for the seamless integration of new features, such as encryption or versioning, without modifying the core VFS implementation.

The use of this pattern is then demonstrated in the following code snippet, which shows how the VFS is initialized and used in the \texttt{main} function:

\begin{lstlisting}[language=c++, basicstyle=\ttfamily\small]
int main(int argc, char* argv[]) {
    CustomVfs custom_vfs();
    VersioningVfs versioned_vfs(custom_vfs);
    EncryptionVfs enc_vers_vfs(versioned_vfs);

    enc_vers_vfs.main(argc, argv);
    return 0;
}
\end{lstlisting}

Anyone can easily add new features to the VFS by implementing a new decorator class and wrapping it around the base VFS\@.

\subsection{Access to VFS features}\label{subsec:access-to-vfs-features}

A crucial aspect of the architecture is determining the method by which users can access the added VFS features.
In this implementation, hooks have been designed to integrate seamlessly with standard filesystem operations.
Additionally, a simple command-line interface (CLI) has been implemented to facilitate access to the VFS features, such as encryption and versioning.

These hooks function by intercepting attempts to read a file with a specific name.
The filesystem then captures this operation, performs the requested action, and returns the result as though it was read from the file.
This approach allows users to interact with the VFS features without deviating from standard filesystem operations.

The CLI consists of two primary components: one for encryption and another for versioning.
Users can execute commands related to these features via the CLI, making it a user-friendly and accessible interface for interacting with the VFS\@.
Commands for encryption may include encryption key management and selecting encryption algorithms, while versioning commands may involve creating new versions, listing available versions, and reverting to a previous version.

Although the current implementation utilizes a command-line interface, the hooks can potentially be integrated into a graphical user interface (GUI) in the future.
Incorporating the VFS features into a GUI would provide users with an even more intuitive and visually appealing interface for managing encryption and versioning.
However, the development of a GUI was beyond the scope of this thesis.

Benefits of this approach include the ability to easily integrate the VFS features into existing applications, such as file managers.
This is because the VFS features are accessed through standard filesystem operations, which are already supported by most applications.
Additionally, the hooks allow for the seamless integration of new features, such as encryption and versioning, without the need to modify the core VFS implementation as can be seen in the following code example:

\begin{lstlisting}[language=c++, basicstyle=\ttfamily\small]
int EncryptionVfs::read(const std::string &ppath,
                     char *buffer,
                     size_t size,
                     off_t offset) {
    if (is_encryption_hook(path)) {
        return handle_hook(path, buffer, size, offset);
    }

    // Do normal read operation...
}
\end{lstlisting}

Similarly, hooks can be implemented for the versioning feature, allowing users to interact with versioning functionality through standard filesystem operations.

\subsection{Architectural overview}\label{subsec:overview}

I will conclude this chapter by providing an overview of the architecture of the VFS\@.
The architecture of our system is designed using object-oriented principles to ensure modularity, extensibility, and maintainability.
The core of the system is built around the FuseWrapper class, which provides a base implementation for interacting with the FUSE library.
By deriving from this base class, we can create custom virtual file systems with various features and functionality.

The CustomVfs class inherits from FuseWrapper and serves as a foundation for more specialized virtual file systems.
By utilizing the decorator pattern, we implement additional functionality in separate classes, such as EncryptionVfs and VersioningVfs, which both inherit from the VfsDecorator class.
This approach allows us to easily extend the system with new features while minimizing the impact on existing code.

The key components of the architecture, along with their relationships and key methods, are illustrated in Figure~\ref{fig:uml_diagram}.
The diagram shows the main classes, their inheritance relationships, and the methods that define their behavior.

\begin{figure}[ht]
    \centering
    \input{architecture}
    \caption{UML diagram of the system architecture.}
    \label{fig:uml_diagram}
\end{figure}