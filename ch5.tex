\chapter{Implementation}
\label{chap:implementation}

Once the preparation phase was complete, it was time to begin the implementation of the custom and extendable VFS\@.

\section{Essential FUSE Operations}\label{sec:fuse-ops}

To successfully implement a custom Virtual File System (VFS) using FUSE, it is essential to define and integrate various FUSE operations.
This section provides a brief overview of some essential FUSE operations, incorporating information from the Facile Engineering tutorial and IBM Developer article~\cite{ibm_fuse, facile_fuse}:

\begin{itemize}
    \item \textbf{getattr}: Retrieves the metadata of a given path.
    This operation is always called before any other operation made on the filesystem.
    It is responsible for reading the file or directory attributes, such as size, access permissions, and timestamps.
    \item \textbf{readdir}: Lists the contents of a directory, filling a buffer with the structure of the accessed directory.
    \item \textbf{open}: Called when the system requests a file to be opened.
    \item \textbf{read}: Called when FUSE is reading data from an opened file.
    It should return exactly the number of bytes requested and fill the buffer with the content of those bytes.
    \item \textbf{write}: Writes data to an open file.
    \item \textbf{mkdir}: Creates a new directory.
    \item \textbf{rmdir}: Deletes an existing directory.
    \item \textbf{rename}: Renames a file or directory.
    \item \textbf{truncate}: Changes the size of a file.
\end{itemize}

Besides these operations a full-featured filesystem might need operations such as \texttt{mknod}, \texttt{unlink}, \texttt{symlink}, \texttt{link}, \texttt{chmod}, \texttt{chown}, \texttt{utime}, \texttt{statfs}, \texttt{flush}, \texttt{release}, \texttt{fsync}, \texttt{setxattr}, \texttt{getxattr}, \texttt{listxattr}, and \texttt{removexattr}.

To create a filesystem with FUSE, a structure variable of type fuse\_operations should be declared and passed to the fuse\_main function.
The fuse\_operations structure contains pointers to functions that will be called when the appropriate action is required.
This is, as described earlier\ref{sec:fuse-in-cpp}, done in the \texttt{FuseWrapper} class and all the other classes simply implement the required functions.

\subsection{Operations for the Base VFS}\label{subsec:base-ops}

The core of the implementation is provided by \texttt{CustomVfs} class, which is responsible for handling all file system operations.
This particular class mainly redirects the operations to the appropriate system calls, which are then handled by the operating system.

\xxx{TODO: describe the operations and how exactly they are implemented - backing directory, etc.}

Using the base VFS is then as simple as creating an object and invoking the \texttt{main} method, as demonstrated in the following code snippet.\ref{lst:main}

\begin{lstlisting}[language=c++, basicstyle=\ttfamily\small, caption={Main method of the \texttt{CustomVfs} class.}, label={lst:main}]
int main(int argc, char* argv[]) {
    CustomVfs custom_vfs();
    custom_vfs.main(argc, argv);
    return 0;
}
\end{lstlisting}

The arguments passed to the \texttt{main} method are then simply forwarded to the wrapper and consequently to the FUSE library.
This allows the user to specify the mount point and other options.


\section{Encryption}\label{sec:encryption}

As mentioed earlier, in order to develop a filesystem using FUSE, a variable of the fuse\_operations structure type should be defined and subsequently passed to the fuse\_main function.
The fuse\_operations structure comprises pointers to functions that will be invoked upon the corresponding action being requested, and that was ex\xxx{...}
This process is facilitated by the \texttt{FuseWrapper} class, while other classes focus on implementing the necessary functions.

The final design incorporates a single \texttt{CustomVfs} class, which is tasked with managing all filesystem operations.
This class primarily directs operations to the relevant system calls, which are subsequently processed by the operating system.

\begin{lstlisting}[language=c++, basicstyle=\ttfamily\small, caption={Wrapping the read operation with encryption.}, label={lst:read}]
int EncVfs::read(const std::string &file_path,
                 char *buffer, size_t size, off_t off) {
    wrapped_vfs_->read(file_path, buffer, size, off);
    decrypt(buffer, size, password);
}
\end{lstlisting}

\xxx{Caching those? Specific key? TODO after implementation.}


\section{Versioning}\label{sec:versioning2}

Instead of using a diff-based approach for versioning, I have chosen to store the entire file in the versioning system as it simplifies the implementation.
Diff-based approach could be implemented in the future.

Similar to the encryption implementation, the read and write operations were wrapped to include versioning.
The following code snippet shows a high-level overview of how to wrap the write operation with versioning functionality.

\begin{lstlisting}[language=c++, basicstyle=\ttfamily\small]
int VersVfs::write(const std::string &file_path,
                   char *buf, size_t size, off_t off) {
    char* prev_buffer;
    read_prev_version(file_path, prev_buffer);

    if (prev_buffer != buffer) {
        // Stores an invisible copy of the file
        store_version(file_path, buf, size);
    }

    wrapped_vfs_->write(file_path, buf, size, off);
}
\end{lstlisting}

\xxx{TODO: describe the operations and how exactly they are implemented - v suffix, hiding them from readdir }